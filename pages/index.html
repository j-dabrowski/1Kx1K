<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/style.css">
    <title>The Million NFT Pixel Webpage</title>
</head>
<body>
    <div id="container">
        <canvas id="grid" width="1000" height="1000"></canvas>
        <div id="coords">x: 0, y: 0</div>
        <div id="controls">

            <div class="control-section" id="theme-section">
                <button id="theme-toggle" class="secondary">
                    <span id="theme-icon">ðŸŒ™</span>
                    Dark Mode
                </button>
            </div>

            <div class="control-section" id="auth-section">
                <input type="text" id="username" placeholder="Enter username" class="w-full p-2 border rounded mb-2">
                <button id="auth-button">Set User</button>
                <p class="hint">Current user: <span id="current-user">None</span></p>
            </div>
            
            <div class="control-section">
                <button id="save-group">Save Selection as Group</button>
                <p class="hint">Click and drag to select/deselect pixels</p>
            </div>

            <div class="control-section">
                <div class="image-upload-container">
                    <input type="file" id="image-upload" accept="image/*">
                    <span class="upload-text">Click to upload image</span>
                </div>
                <p class="hint">First select pixels, save as group, then add image</p>
            </div>

            <div id="image-controls">
                <div class="instructions">
                    <ul>
                        <li>Drag to move image</li>
                        <li>Scroll to resize</li>
                        <li>Double-click to reset position</li>
                    </ul>
                </div>
                <button id="save-image">Apply Image to Group</button>
                <button id="cancel-image" class="secondary">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Generate session ID
        const sessionId = Math.random().toString(36).substring(2, 15);
        const canvas = document.getElementById('grid');
        const ctx = canvas.getContext('2d');
        const coords = document.getElementById('coords');
        const saveGroupBtn = document.getElementById('save-group');
        const imageUpload = document.getElementById('image-upload');
        const imageControls = document.getElementById('image-controls');
        const saveImageBtn = document.getElementById('save-image');
        const cancelImageBtn = document.getElementById('cancel-image');

        const PIXEL_SIZE = 10;
        const GRID_SIZE = 1000;
        const GRID_CELLS = GRID_SIZE / PIXEL_SIZE;

        let isDrawing = false;
        let selectedPixels = new Set();
        let groups = [];
        let currentGroup = null;
        let uploadedImage = null;
        let imageState = { x: 0, y: 0, width: 0, height: 0 };
        let isDraggingImage = false;
        let dragStart = { x: 0, y: 0 };
        let initialImageState = null;

        // Grid drawing
        function drawGrid() {
            ctx.clearRect(0, 0, GRID_SIZE, GRID_SIZE);

            // Base grid
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 0.5;
            for (let i = 0; i < GRID_CELLS; i++) {
                for (let j = 0; j < GRID_CELLS; j++) {
                    ctx.strokeRect(i * PIXEL_SIZE, j * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
                }
            }

            groups.forEach(group => {
            ctx.save();
            
            // Draw filled pixels and image
            ctx.beginPath();
            group.pixels.forEach(pixel => {
                const [x, y] = pixel.split(',');
                ctx.rect(x * PIXEL_SIZE, y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
            });
            ctx.clip();

            if (group.image) {
                ctx.drawImage(group.image, group.imageX, group.imageY, 
                            group.imageWidth, group.imageHeight);
            }

            // Only draw outline if user is logged in and owns this group
            if (currentUser && group.userId === currentUser) {
                ctx.beginPath();
                group.pixels.forEach(pixel => {
                    const [x, y] = pixel.split(',').map(Number);
                    const left = !group.pixels.has(`${x-1},${y}`);
                    const right = !group.pixels.has(`${x+1},${y}`);
                    const top = !group.pixels.has(`${x},${y-1}`);
                    const bottom = !group.pixels.has(`${x},${y+1}`);

                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 2;
                    
                    if (left) {
                        ctx.moveTo(x * PIXEL_SIZE, y * PIXEL_SIZE);
                        ctx.lineTo(x * PIXEL_SIZE, (y + 1) * PIXEL_SIZE);
                    }
                    if (right) {
                        ctx.moveTo((x + 1) * PIXEL_SIZE, y * PIXEL_SIZE);
                        ctx.lineTo((x + 1) * PIXEL_SIZE, (y + 1) * PIXEL_SIZE);
                    }
                    if (top) {
                        ctx.moveTo(x * PIXEL_SIZE, y * PIXEL_SIZE);
                        ctx.lineTo((x + 1) * PIXEL_SIZE, y * PIXEL_SIZE);
                    }
                    if (bottom) {
                        ctx.moveTo(x * PIXEL_SIZE, (y + 1) * PIXEL_SIZE);
                        ctx.lineTo((x + 1) * PIXEL_SIZE, (y + 1) * PIXEL_SIZE);
                    }
                });
                ctx.stroke();
            }
            ctx.restore();
        });

            // Add this block to drawGrid function after drawing groups but before drawing selection
            // Draw currently edited image if exists
            if (uploadedImage && currentGroup) {
                ctx.globalAlpha = 0.4;
                ctx.drawImage(uploadedImage, imageState.x, imageState.y, 
                            imageState.width, imageState.height);
                            
                ctx.globalAlpha = 1;
                ctx.save();
                ctx.beginPath();
                currentGroup.pixels.forEach(pixel => {
                    const [x, y] = pixel.split(',');
                    ctx.rect(x * PIXEL_SIZE, y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
                });
                ctx.clip();
                ctx.drawImage(uploadedImage, imageState.x, imageState.y, 
                            imageState.width, imageState.height);
                ctx.restore();
            }

            // Draw current selection
            ctx.fillStyle = 'rgba(0, 120, 255, 0.3)';
            ctx.strokeStyle = '#0066cc';
            ctx.lineWidth = 2;
            selectedPixels.forEach(pixel => {
                const [x, y] = pixel.split(',');
                ctx.fillRect(x * PIXEL_SIZE, y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
                ctx.strokeRect(x * PIXEL_SIZE, y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
            });
        }

        function getGridPosition(event) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = Math.floor((event.clientX - rect.left) * scaleX / PIXEL_SIZE);
            const y = Math.floor((event.clientY - rect.top) * scaleY / PIXEL_SIZE);
            return [x, y];
        }

        function isPixelInGroup(x, y) {
            const pixel = `${x},${y}`;
            return groups.some(group => group.pixels.has(pixel));
        }

        function calculateInitialImagePosition(group) {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            group.pixels.forEach(pixel => {
                const [x, y] = pixel.split(',').map(Number);
                minX = Math.min(minX, x * PIXEL_SIZE);
                minY = Math.min(minY, y * PIXEL_SIZE);
                maxX = Math.max(maxX, (x + 1) * PIXEL_SIZE);
                maxY = Math.max(maxY, (y + 1) * PIXEL_SIZE);
            });

            const groupWidth = maxX - minX;
            const groupHeight = maxY - minY;
            const imgAspect = uploadedImage.width / uploadedImage.height;
            const groupAspect = groupWidth / groupHeight;
            
            let width, height;
            if (imgAspect > groupAspect) {
                width = groupWidth;
                height = groupWidth / imgAspect;
            } else {
                height = groupHeight;
                width = groupHeight * imgAspect;
            }

            return {
                x: minX + (groupWidth - width) / 2,
                y: minY + (groupHeight - height) / 2,
                width,
                height
            };
        }

        function setImageMode(enabled) {
            if (enabled) {
                canvas.classList.add('image-mode');
                imageControls.style.display = 'block';
            } else {
                canvas.classList.remove('image-mode');
                imageControls.style.display = 'none';
            }
        }

        async function saveGroup(group) {
            if (!currentUser) {
                alert('Please set a username first');
                return;
            }
   
            const groupData = {
                sessionId,
                userId: currentUser,
                pixels: Array.from(group.pixels),
                image: group.image ? {
                    url: group.image.src,
                    x: group.imageX,
                    y: group.imageY,
                    width: group.imageWidth,
                    height: group.imageHeight
                } : null
            };

            try {
                const response = await fetch('/api/save-group', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(groupData)
                });
                return await response.json();
            } catch (error) {
                console.error('Error saving group:', error);
            }
        }

        async function loadGroups() {
            try {
                const response = await fetch('/api/load-all-groups');
                const allGroupsData = await response.json();
                
                for (const [storedSessionId, groupsData] of Object.entries(allGroupsData)) {
                    for (const groupData of groupsData) {
                        const group = {
                            userId: groupData.userId,  // Add this line
                            pixels: new Set(groupData.pixels),
                            imageX: groupData.image?.x || 0,
                            imageY: groupData.image?.y || 0,
                            imageWidth: groupData.image?.width || 0,
                            imageHeight: groupData.image?.height || 0
                        };
                        if (groupData.image) {
                            const img = new Image();
                            img.onload = () => {
                                group.image = img;
                                drawGrid();
                            };
                            img.src = groupData.image.url;
                        }
                        groups.push(group);
                    }
                }
                drawGrid();
            } catch (error) {
                console.error('Error loading groups:', error);
            }
        }

        const themeToggle = document.getElementById('theme-toggle');
        const themeIcon = document.getElementById('theme-icon');
        
        themeToggle.addEventListener('click', () => {
            document.body.classList.toggle('dark-mode');
            themeIcon.textContent = document.body.classList.contains('dark-mode') ? 'â˜€ï¸' : 'ðŸŒ™';
        });

        let currentUser = null;
        const userDisplay = document.getElementById('current-user');
        const usernameInput = document.getElementById('username');
        const authButton = document.getElementById('auth-button');

        authButton.addEventListener('click', () => {
            const username = usernameInput.value.trim();
            if (username) {
                currentUser = username;
                userDisplay.textContent = username;
                usernameInput.value = '';
                drawGrid();  // Redraw to update highlights
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            const [x, y] = getGridPosition(e);
            
            if (uploadedImage && currentGroup) {
                isDraggingImage = true;
                dragStart = {
                    x: e.clientX - imageState.x,
                    y: e.clientY - imageState.y
                };
            } else if (!isPixelInGroup(x, y)) {
                isDrawing = true;
                const pixel = `${x},${y}`;
                selectionMode = selectedPixels.has(pixel) ? 'deselect' : 'select';
                if (selectionMode === 'deselect') {
                    selectedPixels.delete(pixel);
                } else {
                    selectedPixels.add(pixel);
                }
                drawGrid();
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const [x, y] = getGridPosition(e);
            coords.textContent = `x: ${x}, y: ${y}`;

            if (isDraggingImage) {
                imageState.x = e.clientX - dragStart.x;
                imageState.y = e.clientY - dragStart.y;
                drawGrid();
            } else if (isDrawing && !isPixelInGroup(x, y)) {
                const pixel = `${x},${y}`;
                if (selectionMode === 'deselect') {
                    selectedPixels.delete(pixel);
                } else {
                    selectedPixels.add(pixel);
                }
                drawGrid();
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
            isDraggingImage = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDrawing = false;
            isDraggingImage = false;
        });

        canvas.addEventListener('wheel', (e) => {
            if (uploadedImage) {
                e.preventDefault();
                const scale = e.deltaY > 0 ? 0.9 : 1.1;
                
                const centerX = imageState.x + imageState.width / 2;
                const centerY = imageState.y + imageState.height / 2;
                
                imageState.width *= scale;
                imageState.height *= scale;
                imageState.x = centerX - imageState.width / 2;
                imageState.y = centerY - imageState.height / 2;
                
                drawGrid();
            }
        });

        canvas.addEventListener('dblclick', () => {
            if (uploadedImage && initialImageState) {
                imageState = { ...initialImageState };
                drawGrid();
            }
        });


        // Update saveGroupBtn click handler
        saveGroupBtn.addEventListener('click', async () => {
            if (selectedPixels.size > 0) {
                const newGroup = {
                    userId: currentUser,
                    pixels: new Set(selectedPixels),
                    image: null,
                    imageX: 0,
                    imageY: 0,
                    imageWidth: 0,
                    imageHeight: 0
                };
                await saveGroup(newGroup);
                groups.push(newGroup);
                selectedPixels.clear();
                drawGrid();
            }
        });

        imageUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file && groups.length > 0) {
                const img = new Image();
                img.onload = () => {
                    uploadedImage = img;
                    currentGroup = groups[groups.length - 1];
                    
                    const initialState = calculateInitialImagePosition(currentGroup);
                    imageState = { ...initialState };
                    initialImageState = { ...initialState };

                    setImageMode(true);
                    drawGrid();
                };
                img.src = URL.createObjectURL(file);
            }
        });

        saveImageBtn.addEventListener('click', async () => {
    if (currentGroup && uploadedImage) {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        currentGroup.pixels.forEach(pixel => {
            const [x, y] = pixel.split(',').map(Number);
            minX = Math.min(minX, x * PIXEL_SIZE);
            minY = Math.min(minY, y * PIXEL_SIZE);
            maxX = Math.max(maxX, (x + 1) * PIXEL_SIZE);
            maxY = Math.max(maxY, (y + 1) * PIXEL_SIZE);
        });

        const width = maxX - minX;
        const height = maxY - minY;

        const cropCanvas = document.createElement('canvas');
        cropCanvas.width = width;
        cropCanvas.height = height;
        const cropCtx = cropCanvas.getContext('2d');

        cropCtx.clearRect(0, 0, width, height);
        cropCtx.beginPath();
        currentGroup.pixels.forEach(pixel => {
            const [x, y] = pixel.split(',').map(Number);
            cropCtx.rect((x * PIXEL_SIZE) - minX, (y * PIXEL_SIZE) - minY, PIXEL_SIZE, PIXEL_SIZE);
        });
        cropCtx.clip();

        cropCtx.drawImage(uploadedImage, 
            imageState.x - minX, imageState.y - minY,
            imageState.width, imageState.height);

        const imageData = cropCanvas.toDataURL('image/png');
        
        try {
            const response = await fetch('/api/save-image', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    imageData: imageData,
                    groupId: currentGroup.id || Date.now()
                })
            });
            
            const savedImageUrl = await response.text();
            const croppedImage = new Image();
            
            croppedImage.onload = async () => {
                const updatedGroup = {
                    pixels: currentGroup.pixels,
                    image: croppedImage,
                    imageX: minX,
                    imageY: minY,
                    imageWidth: width,
                    imageHeight: height
                };

                // Replace the current group with updated version
                const groupIndex = groups.indexOf(currentGroup);
                if (groupIndex !== -1) {
                    groups[groupIndex] = updatedGroup;
                }
                
                await saveGroup(updatedGroup);
                currentGroup = null;
                uploadedImage = null;
                setImageMode(false);
                imageUpload.value = '';
                drawGrid();
            };
            
            croppedImage.src = savedImageUrl;
        } catch (error) {
            console.error('Error saving image:', error);
        }
    }
});

        cancelImageBtn.addEventListener('click', () => {
            currentGroup = null;
            uploadedImage = null;
            setImageMode(false);
            imageUpload.value = '';
            drawGrid();
        });

        loadGroups();

        drawGrid();
    </script>
</body>
</html>